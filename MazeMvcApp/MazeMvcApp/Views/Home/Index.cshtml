@model MazeMvcApp.Models.Maze

<head>
    <meta name="viewport" content="width=device-width" />
    <title>Maze Generator App</title>

    <style>
        body 
        {
            background-color: #c1bebe;
            color: #333;
            font-family: Arial, calibri;
            margin: 0;
            padding: 0;
        }

        .container 
        {
            max-width: 75%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        h1 
        {
            color: #4b0082;
            text-align: center;
            margin-top: 15px;
        }

        /* margin:auto; horizontally centers the card even as the maze width increases */
        .card 
        {
            background-color: snow;
            width: 420px;
            margin: auto;
            box-shadow: rgba(136, 165, 191, 1) 6px 2px 16px 0px, rgba(255, 255, 255, 0.8) -6px -2px 16px 0px;
        }

        /* Added .card selector so that this should just affect the h2 and h4 for the pop-up */
        .card h2 
        {
            margin-left: 17px;
            margin-bottom: 1rem;
            text-decoration: underline;
        }

        .card h4 
        {
            margin-left: 17px;
            margin-bottom: 1rem;
            text-decoration: underline;
        }

        .card p 
        {
            margin-left: 17px;
        }

        .form-group 
        {
            display: flex;
            align-items: center;
            margin-top: 12px;
            margin-bottom: 15px;
        }

        .form-label 
        {
            font-weight: bold;
            margin-left: 12px;
            margin-bottom: 0px;
        }

        .maze-container 
        {
            border-radius: 5px;
            padding-top: 50px;
        }

        /* max-wdith: max-content makes maze div outer div width fit inner div width */
        .maze 
        {
            display: grid;
            grid-template-rows: repeat(@Model.NRow, 20px);
            background-color: white;
            max-width: max-content;
            box-shadow: rgba(136, 165, 191, 1) 6px 2px 16px 0px, rgba(255, 255, 255, 0.8) -6px -2px 16px 0px;
        }

        .maze-row 
        {
            display: flex;
        }

        .button 
        {
            display: inline-block;
            padding: 10px 10px;
            background-color: #4b0082;
            color: #fff;
            text-decoration: none;
            border-radius: 5px;
            margin-right: 20px;
            width: 140px;
        }

        .button:hover
        {
            background-color: #800080;
        }

        .form-control 
        {
            width: 70px;
        }

         #appTutorial
         {
            color: blue;
            text-decoration: underline;
            cursor: pointer;
            font-weight: bold;
            margin: auto;
        }

        #open-modal-btn 
        {
           color: blue;
           text-decoration: underline;
           cursor: pointer;
           font-weight: bold;
           margin: auto;
        }

        #close-modal-btn
        {
           float: right;
           font-size: 28px;
           font-weight: bold;
           cursor: pointer;
        }

        .modal 
        {
           display: none; /* Hidden by default */
           position: fixed; /* Fixed position */
           z-index: 1; /* Place the modal popup on top of other elements */
           left: 0;
           top: 0;
           width: 100%; /* Full width */
           height: 100%; /* Full height */
           overflow: auto; /* Enable scrolling if needed */
           background-color: rgba(0, 0, 0, 0.5); /* Black background with transparency */
        }

        .modal-content 
        {
           display: block;
           background-color: #fefefe;
           margin: 10% auto; /* Centered vertically and horizontally */
           padding: 20px;
           border: 1px solid #888;
           max-width: 550px;
           border-radius: 10px;
        }

        #prev-btn 
        {
           margin-left: 17px;
        }

        .maze-cell:hover 
        {
          background-color: lightblue;
        }

        .close:hover,
        .close:focus 
        {
           color: #000;
           text-decoration: none;
           cursor: pointer;
        }

        /* for the css transition used in valid path display */
        .transformed-state-validPath 
        {
            background-color: #00ffa1 !important;
            transition-property: background-color, transform;
            transition-timing-function: linear;
            transition-duration: 3s;
        }

         /* for the css transition used in the algorithm search display */
        .transformed-state-algorithmSearchDisplay 
        {
            background-color: yellow !important;
            transition-property: background-color, transform;
            transition-timing-function: linear;
            transition-duration: 3s;
        }

    </style>

</head>

<body>

    <div class="card">

        <div class="card-header">
            <h1>
                Maze Generator
            </h1>
        </div>

        <div class="card-body">
            <!-- Button to open the modal -->
            <a id="open-modal-btn">TUTORIAL</a>

            <!-- The modal -->
            <div id="modal" class="modal">
              <div class="modal-content">
                <span id="close-modal-btn">&times;</span>
                <!-- Keep these empty, populate with JS -->
                <h2></h2>
                <p></p>
                <h4></h4>
                <ul id="modal-list"></ul>
                <button id="prev-btn">Previous</button>
                <button id="next-btn">Next</button>
              </div>
            </div>

            <!-- Home is the controller, asp-action is the method -->
            <form asp-controller="Home" asp-action="GenerateMaze" method="post">
                <div class="form-group">
                    <input name="nRow" type="number" class="form-control" />
                     <label class="form-label">Number of Rows (3 - 60)</label>
                </div>

                <div class="form-group">
                    <input name="nCol" type="number" class="form-control" />
                    <label class="form-label">Number of Columns (3 - 60) </label>
                </div>

                <div class="form-group">
                    <button type="submit" class="button">Create Maze</button>
                </div>
            </form>

            <!-- If I put these buttons in the form an error happens, something to do with submit I think -->
            <div class="form-group">
                <button id="solveMaze" class="button">Display Path</button>
                <button id="clearPath" class="button">Clear Path</button>
            </div>

            <div class="form-group">
                @using (Html.BeginForm("ClearMaze", "Home", FormMethod.Post))
                {
                    <button class="button" type="submit">Clear Maze</button>
                }
            </div>

            <button id="algorithmSearchDisplay" class="button">Show Algorithm</button>

            <form id="algorithmChoiceForm" action="/Home/ChooseAlgorithm" method="post">
              <select id="dropdown" name="selectedAlgorithm">
                <option value="dfs">Depth-First Search</option>
                <option value="bfs">Breadth-First Search</option>
                <option value="aStar">A*</option>
              </select>
              <button type="submit">Confirm</button>
            </form>

        </div>
    </div>

    <div class="maze-container">
        <div class="maze">
            @if (@Model.NRow > 1 && @Model.NCol > 1)
            {
                @for (int i = 0; i < @Model.NRow; i++)
                {
                    <div class="maze-row">
                        @for (int j = 0; j < @Model.NCol; j++)
                        {
                            <!-- This is to make cell height & width a percentage of table row / col -->
                            double a = 100 / @Model.NCol;
                            string a2 = a.ToString() + '%';

                            <!-- creating new class for each cell -->
                            <!-- Added space between maze-cell and coords-y etc because I needed to select the cells in js -->
                            <div class="maze-cell coords-y@(i)x@(j)">

                                @if (@Model.Cells[i][j] == @Model.StartCell) 
                                {
                                    <style> .coords-y@(i)x@(j) { background-color: green; } </style>
                                }

                                @if (@Model.Cells[i][j] == @Model.EndCell) 
                                {
                                    <style> .coords-y@(i)x@(j) { background-color: red; } </style>
                                }

                                @if (@Model.Cells[i][j].DisplayTopEdge == true)
                                {
                                    <style>
                                        .coords-y@(i)x@(j) 
                                        {
                                            position: relative;
                                            border-top: 3px solid black;
                                            height: 20px;
                                            width: 20px;
                                        }
                                    </style>
                                }

                                @if (@Model.Cells[i][j].DisplayLeftEdge == true)
                                {
                                    <style>
                                        .coords-y@(i)x@(j) 
                                        {
                                            position: relative;
                                            border-left: 3px solid black;
                                            height: 20px;
                                            width: 20px;
                                        }
                                    </style>
                                }

                                @if ( (@Model.Cells[i][j].DisplayTopEdge == false)
                                        && (@Model.Cells[i][j].DisplayLeftEdge == false) 
                                        && (@Model.Cells[i][j].BottomEdge == false)
                                        && (@Model.Cells[i][j].RightEdge == false) )
                                {
                                    <style>
                                        .coords-y@(i)x@(j) 
                                        {
                                            position: relative;
                                            height: 20px;
                                            width: 20px;
                                        }
                                    </style>
                                }

                                @if (@Model.Cells[i][j].BottomEdge == true)
                                {
                                    <style>
                                        .coords-y@(i)x@(j) 
                                        {
                                            position: relative;
                                            border-bottom: 3px solid black;
                                            height: 20px;
                                            width: 20px;
                                        }
                                    </style>
                                }

                                @if (@Model.Cells[i][j].RightEdge == true)
                                {
                                    <style>
                                        .coords-y@(i)x@(j) 
                                        {
                                            position: relative;
                                            border-right: 3px solid black;
                                            height: 20px;
                                            width: 20px;
                                        }
                                    </style>
                                }

                                <!-- All edges open -->
                                @if ( (@Model.Cells[i][j].TopEdge == false) 
                                        && (@Model.Cells[i][j].BottomEdge == false)
                                        && (@Model.Cells[i][j].LeftEdge == false)
                                        && (@Model.Cells[i][j].RightEdge == false))
                                {
                                    <style>
                                        .coords-y@(i)x@(j) 
                                        {
                                            position: relative;
                                            height: 20px;
                                            width: 20px;
                                        }
                                    </style>
                                }

                                <!-- Display algorithm working -->
                                @if(Model.AlgorithmDisplayMap.ContainsKey(Model.Cells[i][j])
                                && (@Model.Cells[i][j] != @Model.StartCell) 
                                && (@Model.Cells[i][j] != @Model.EndCell) )
                                {
                                    string delayStrAlgorithmDisplay = @Model.AlgorithmDisplayMap[@Model.Cells[i][j]].ToString() + "s";

                                    <div class="algorithmPath path-div-y@(i)x@(j)">
                                                        
                                    </div>

                                    <style>
                                        .path-div-y@(i)x@(j)
                                        {
                                            position: absolute;
                                            top: 0;
                                            right: 0;
                                            bottom: 0;
                                            left: 0;
                                            transition-property: background-color, transform;
                                            transition-timing-function: linear;
                                            transition-duration: 3s;
                                            transition-delay: @delayStrAlgorithmDisplay;
                                        }
                                    </style>
                                }

                                <!-- Valid path display -->
                                @if(@Model.ValidPathDelayMap.ContainsKey(@Model.Cells[i][j])
                                && (@Model.Cells[i][j] != @Model.StartCell) 
                                && (@Model.Cells[i][j] != @Model.EndCell) )
                                {
                                    string delayStrValidPath = @Model.ValidPathDelayMap[@Model.Cells[i][j]].ToString() + "s";

                                    <!-- space between solution and path allows me select solution in JS
                                        and path in CSS as follows. They're separate selectors now
                                    -->
                                    <div class="solution path-div-y@(i)x@(j)">
                                                        
                                    </div>

                                    <style>
                                        .path-div-y@(i)x@(j)
                                        {
                                            position: absolute;
                                            top: 0;
                                            right: 0;
                                            bottom: 0;
                                            left: 0;
                                            transition-property: background-color, transform;
                                            transition-timing-function: linear;
                                            transition-duration: 3s;
                                            transition-delay: @delayStrValidPath;
                                        }
                                    </style>
                                }

                                @Model.Cells[i][j].ToEmptyString()
                                            
                            </div>
                        }
                    </div>
                }
            }
        </div>
    </div>

    <script type="text/javascript">

        // DISPLAY VALID PATH
        function solveMazeFunc() 
        {
            const elements = document.querySelectorAll("div.solution");
            for (const element of elements) 
            {
                element.classList.toggle("transformed-state-validPath");
            }
        }

        const solveMazeButton = document.querySelector("#solveMaze");
        solveMazeButton.addEventListener("click", solveMazeFunc);

        // CLEAR VALID PATH
        function clearValidPath()
        {
            var scrollX = window.scrollX || window.pageXOffset;
            var scrollY = window.scrollY || window.pageYOffset;
            window.location.reload();
            window.scrollTo(scrollX, scrollY);
        }

        const clearPathButton = document.querySelector("#clearPath");
        clearPathButton.addEventListener("click", clearValidPath);

        // ALGORITHM SEARCH DISPLAY
        function showSearchAlgorithmWorking() 
        {
            const elements = document.querySelectorAll("div.algorithmPath");
            for (const element of elements) 
            {
                element.classList.toggle("transformed-state-algorithmSearchDisplay");
            }
        }

        const algorithmSearchDisplayButton = document.querySelector("#algorithmSearchDisplay");
        algorithmSearchDisplayButton.addEventListener("click", showSearchAlgorithmWorking);

        // ALLOW USER TO DRAW THEIR OWN PATH
        // Maybe should be left click to draw path, right to eraze
        // Also the startCell and EndCell shouldn't get colored over
        /*
        const mazeCells = document.querySelectorAll("div.maze-cell");
        for (const cell of mazeCells)
        {
            cell.addEventListener("mousedown", func, false);
        }
        function func(event)
        {
            if(event.buttons === 0)
            {
                this.setAttribute("style", "background-color:lightblue;") // left mouse button
            }
            else if(event.buttons === 2)
            {
                this.setAttribute("style", "background-color:white;") // right mouse button
            }
        }*/

        // DOMContentLoaded fires when the initial HTML document is completely loaded & parsed
        document.addEventListener('DOMContentLoaded', function() 
        {
          let cells = document.querySelectorAll("div.maze-cell");

          cells.forEach(function(cell) 
          {
            cell.addEventListener('mousedown', function(event) 
            {
              if (event.button === 0) // Left mouse button
              { 
                this.style.backgroundColor = 'lightblue';
              } 
              else if (event.button === 2) // Right mouse button
              { 
                this.style.backgroundColor = 'white';
              }
            });

            // This is needed so that js detects user is keeping left or right button held down
            cell.addEventListener('mouseover', function() 
            {
                if (event.buttons === 1) // Left mouse button
                { 
                    this.style.backgroundColor = 'lightblue';
                } 
                else if (event.buttons === 2) // Right mouse button
                { 
                    this.style.backgroundColor = 'white';
                }
            });

            // This prevents the context menu from popping up when the user right clicks on a cell
            cell.addEventListener('contextmenu', function(event) 
            {
              event.preventDefault();
            });
          });
        });

        // MULTIPLE MODAL
        // Get references to DOM elements
        const openModalBtn = document.getElementById('open-modal-btn');
        const modal = document.getElementById('modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const overlay = document.getElementById('overlay');

        // Modal content
        const modalContent = [
          {
            title: 'Welcome to Maze Generator',
            content: 'The goal of this application is to generate mazes of various sizes and complexities, and allow users to have fun interacting with those mazes.',
            subheader: 'Key Features:',
            listData: [ 'Generate mazes according to your specifications', 'Draw your own path through the maze: Hold left mouse-button down to draw your path, and hold right mouse-button down to eraze your path', 'Display a valid path through the maze automatically' ]
          },
          {
            title: 'Buttons & Inputs',
            content: '',
            subheader: '',
            listData: [ 'Choose how many rows and columns you want the generated maze to have with the input boxes. Once you have entered both, click on the Generate Maze button',
                       'The Clear Path button will clear the maze of any path which has been generated either by the app or by yourself', 
                        'The Clear Maze button will destroy the current maze if one exists' ]
          }];

        let currentIndex = 0;

        function showModal() 
        {
          document.getElementById("modal").style.display = "block";
        }

        function hideModal() 
        {
          document.getElementById("modal").style.display = "none";
        }

        // Populate current modal content
        function showContent(index) 
        {
          // Retrieve current modal content from modalContent list and map it to appropriate element
          const content = modalContent[index];
          const modalTitle = modal.querySelector('h2');
          const modalText = modal.querySelector('p');
          const modalSubheader = modal.querySelector('h4');
          const modalList = document.getElementById('modal-list');
          
          modalTitle.textContent = content.title;
          modalText.textContent = content.content;
          modalSubheader.textContent = content.subheader;
          for(i = 0; i < content.listData.length; ++i) 
          {
              var li = document.createElement('li');
              li.innerText = content.listData[i];
              modalList.appendChild(li);
          }

          // greys out buttons on the modal where appropriate
          prevBtn.disabled = index === 0;
          nextBtn.disabled = index === modalContent.length - 1;
        }

        // Event listeners to control flow
        openModalBtn.addEventListener('click', showModal);
        closeModalBtn.addEventListener('click', hideModal);

        // Clear modalList for prev and next buttons , otherwise just keeps appending 
        // repeating li elements on each previous or next button click in the modal
        prevBtn.addEventListener('click', () => {
          const modalList = document.getElementById('modal-list');
          modalList.innerHTML = '';
          currentIndex--;
          showContent(currentIndex);
        });

        nextBtn.addEventListener('click', () => {
          const modalList = document.getElementById('modal-list');
          modalList.innerHTML = '';
          currentIndex++;
          showContent(currentIndex);
        });

        showContent(currentIndex);

    </script>

</body>